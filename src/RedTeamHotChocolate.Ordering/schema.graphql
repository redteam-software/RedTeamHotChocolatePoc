schema {
  query: Query
  mutation: Mutation
}

type LineItem {
  product: Product!
  id: Int!
  quantity: Int!
}

type Mutation {
  createOrder(orderInput: OrderInput!): OrderCreatedPayload! @cost(weight: "10")
}

type Order {
  "example of field level auth"
  totalLineItems: Decimal @authorize(policy: "AdminPolicy") @cost(weight: "10")
  id: Int!
  name: String!
  description: String!
  items: [LineItem!]!
}

type OrderCreatedPayload {
  order: Order!
}

type Product {
  id: Int!
}

type Query {
  orders(where: OrderFilterInput @cost(weight: "10")): [Order!]! @cost(weight: "10")
}

input IntOperationFilterInput {
  eq: Int @cost(weight: "10")
  neq: Int @cost(weight: "10")
  in: [Int] @cost(weight: "10")
  nin: [Int] @cost(weight: "10")
  gt: Int @cost(weight: "10")
  ngt: Int @cost(weight: "10")
  gte: Int @cost(weight: "10")
  ngte: Int @cost(weight: "10")
  lt: Int @cost(weight: "10")
  nlt: Int @cost(weight: "10")
  lte: Int @cost(weight: "10")
  nlte: Int @cost(weight: "10")
}

input LinItemInput {
  id: Int!
  quantity: Int!
  productId: Int!
}

input LineItemFilterInput {
  and: [LineItemFilterInput!]
  or: [LineItemFilterInput!]
  id: IntOperationFilterInput
  quantity: IntOperationFilterInput
  productId: IntOperationFilterInput
}

input ListFilterInputTypeOfLineItemFilterInput {
  all: LineItemFilterInput @cost(weight: "10")
  none: LineItemFilterInput @cost(weight: "10")
  some: LineItemFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input OrderFilterInput {
  and: [OrderFilterInput!]
  or: [OrderFilterInput!]
  id: IntOperationFilterInput
  name: StringOperationFilterInput
  description: StringOperationFilterInput
  items: ListFilterInputTypeOfLineItemFilterInput
}

input OrderInput {
  id: Int!
  name: String!
  description: String!
  linItems: [LinItemInput!]!
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String @cost(weight: "10")
  neq: String @cost(weight: "10")
  contains: String @cost(weight: "20")
  ncontains: String @cost(weight: "20")
  in: [String] @cost(weight: "10")
  nin: [String] @cost(weight: "10")
  startsWith: String @cost(weight: "20")
  nstartsWith: String @cost(weight: "20")
  endsWith: String @cost(weight: "20")
  nendsWith: String @cost(weight: "20")
}

"Defines when a policy shall be executed."
enum ApplyPolicy {
  "Before the resolver was executed."
  BEFORE_RESOLVER
  "After the resolver was executed."
  AFTER_RESOLVER
  "The policy is applied in the validation step before the execution."
  VALIDATION
}

"The authorize directive."
directive @authorize("The name of the authorization policy that determines access to the annotated resource." policy: String "Roles that are allowed to access the annotated resource." roles: [String!] "Defines when when the authorize directive shall be applied.By default the authorize directives are applied during the validation phase." apply: ApplyPolicy! = BEFORE_RESOLVER) repeatable on OBJECT | FIELD_DEFINITION

"The purpose of the `cost` directive is to define a `weight` for GraphQL types, fields, and arguments. Static analysis can use these weights when calculating the overall cost of a query or response."
directive @cost("The `weight` argument defines what value to add to the overall cost for every appearance, or possible appearance, of a type, field, argument, etc." weight: String!) on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | ENUM | INPUT_FIELD_DEFINITION

"The `Decimal` scalar type represents a decimal floating-point number."
scalar Decimal